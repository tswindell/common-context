// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: crdt.proto
#ifndef GRPC_crdt_2eproto__INCLUDED
#define GRPC_crdt_2eproto__INCLUDED

#include "crdt.pb.h"

#include <grpc++/support/async_stream.h>
#include <grpc++/impl/rpc_method.h>
#include <grpc++/impl/proto_utils.h>
#include <grpc++/impl/service_type.h>
#include <grpc++/support/async_unary_call.h>
#include <grpc++/support/status.h>
#include <grpc++/support/stub_options.h>
#include <grpc++/support/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace crdt {

class CRDT GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Create(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::crdt::CreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CreateResponse>> AsyncCreate(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CreateResponse>>(AsyncCreateRaw(context, request, cq));
    }
    virtual ::grpc::Status Attach(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::crdt::AttachResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    virtual ::grpc::Status Detach(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::crdt::DetachResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::DetachResponse>> AsyncDetach(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::DetachResponse>>(AsyncDetachRaw(context, request, cq));
    }
    virtual ::grpc::Status Commit(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::crdt::CommitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CommitResponse>> AsyncCommit(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CommitResponse>>(AsyncCommitRaw(context, request, cq));
    }
    virtual ::grpc::Status Equals(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::crdt::EqualsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::EqualsResponse>> AsyncEquals(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::EqualsResponse>>(AsyncEqualsRaw(context, request, cq));
    }
    virtual ::grpc::Status Merge(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::crdt::MergeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::MergeResponse>> AsyncMerge(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::MergeResponse>>(AsyncMergeRaw(context, request, cq));
    }
    virtual ::grpc::Status Clone(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::crdt::CloneResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CloneResponse>> AsyncClone(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CloneResponse>>(AsyncCloneRaw(context, request, cq));
    }
    virtual ::grpc::Status SupportedTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedTypesResponse>> AsyncSupportedTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedTypesResponse>>(AsyncSupportedTypesRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSupportedType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>> AsyncIsSupportedType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>>(AsyncIsSupportedTypeRaw(context, request, cq));
    }
    virtual ::grpc::Status SupportedStorageTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedStorageTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedStorageTypesResponse>> AsyncSupportedStorageTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedStorageTypesResponse>>(AsyncSupportedStorageTypesRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSupportedStorageType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>> AsyncIsSupportedStorageType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>>(AsyncIsSupportedStorageTypeRaw(context, request, cq));
    }
    virtual ::grpc::Status SupportedCryptoMethods(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedCryptoMethodsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedCryptoMethodsResponse>> AsyncSupportedCryptoMethods(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedCryptoMethodsResponse>>(AsyncSupportedCryptoMethodsRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSupportedCryptoMethod(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>> AsyncIsSupportedCryptoMethod(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>>(AsyncIsSupportedCryptoMethodRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CreateResponse>* AsyncCreateRaw(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::DetachResponse>* AsyncDetachRaw(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CommitResponse>* AsyncCommitRaw(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::EqualsResponse>* AsyncEqualsRaw(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::MergeResponse>* AsyncMergeRaw(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::CloneResponse>* AsyncCloneRaw(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedTypesResponse>* AsyncSupportedTypesRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>* AsyncIsSupportedTypeRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedStorageTypesResponse>* AsyncSupportedStorageTypesRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>* AsyncIsSupportedStorageTypeRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SupportedCryptoMethodsResponse>* AsyncSupportedCryptoMethodsRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::BooleanResponse>* AsyncIsSupportedCryptoMethodRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::Channel>& channel);
    ::grpc::Status Create(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::crdt::CreateResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CreateResponse>> AsyncCreate(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CreateResponse>>(AsyncCreateRaw(context, request, cq));
    }
    ::grpc::Status Attach(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::crdt::AttachResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    ::grpc::Status Detach(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::crdt::DetachResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::DetachResponse>> AsyncDetach(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::DetachResponse>>(AsyncDetachRaw(context, request, cq));
    }
    ::grpc::Status Commit(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::crdt::CommitResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CommitResponse>> AsyncCommit(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CommitResponse>>(AsyncCommitRaw(context, request, cq));
    }
    ::grpc::Status Equals(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::crdt::EqualsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::EqualsResponse>> AsyncEquals(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::EqualsResponse>>(AsyncEqualsRaw(context, request, cq));
    }
    ::grpc::Status Merge(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::crdt::MergeResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::MergeResponse>> AsyncMerge(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::MergeResponse>>(AsyncMergeRaw(context, request, cq));
    }
    ::grpc::Status Clone(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::crdt::CloneResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CloneResponse>> AsyncClone(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::CloneResponse>>(AsyncCloneRaw(context, request, cq));
    }
    ::grpc::Status SupportedTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedTypesResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedTypesResponse>> AsyncSupportedTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedTypesResponse>>(AsyncSupportedTypesRaw(context, request, cq));
    }
    ::grpc::Status IsSupportedType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>> AsyncIsSupportedType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>>(AsyncIsSupportedTypeRaw(context, request, cq));
    }
    ::grpc::Status SupportedStorageTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedStorageTypesResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedStorageTypesResponse>> AsyncSupportedStorageTypes(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedStorageTypesResponse>>(AsyncSupportedStorageTypesRaw(context, request, cq));
    }
    ::grpc::Status IsSupportedStorageType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>> AsyncIsSupportedStorageType(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>>(AsyncIsSupportedStorageTypeRaw(context, request, cq));
    }
    ::grpc::Status SupportedCryptoMethods(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::crdt::SupportedCryptoMethodsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedCryptoMethodsResponse>> AsyncSupportedCryptoMethods(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SupportedCryptoMethodsResponse>>(AsyncSupportedCryptoMethodsRaw(context, request, cq));
    }
    ::grpc::Status IsSupportedCryptoMethod(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::crdt::BooleanResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>> AsyncIsSupportedCryptoMethod(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>>(AsyncIsSupportedCryptoMethodRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::Channel> channel_;
    ::grpc::ClientAsyncResponseReader< ::crdt::CreateResponse>* AsyncCreateRaw(::grpc::ClientContext* context, const ::crdt::CreateRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::crdt::AttachRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::DetachResponse>* AsyncDetachRaw(::grpc::ClientContext* context, const ::crdt::DetachRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::CommitResponse>* AsyncCommitRaw(::grpc::ClientContext* context, const ::crdt::CommitRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::EqualsResponse>* AsyncEqualsRaw(::grpc::ClientContext* context, const ::crdt::EqualsRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::MergeResponse>* AsyncMergeRaw(::grpc::ClientContext* context, const ::crdt::MergeRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::CloneResponse>* AsyncCloneRaw(::grpc::ClientContext* context, const ::crdt::CloneRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SupportedTypesResponse>* AsyncSupportedTypesRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>* AsyncIsSupportedTypeRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SupportedStorageTypesResponse>* AsyncSupportedStorageTypesRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>* AsyncIsSupportedStorageTypeRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SupportedCryptoMethodsResponse>* AsyncSupportedCryptoMethodsRaw(::grpc::ClientContext* context, const ::crdt::EmptyMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::BooleanResponse>* AsyncIsSupportedCryptoMethodRaw(::grpc::ClientContext* context, const ::crdt::TypeMessage& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_Create_;
    const ::grpc::RpcMethod rpcmethod_Attach_;
    const ::grpc::RpcMethod rpcmethod_Detach_;
    const ::grpc::RpcMethod rpcmethod_Commit_;
    const ::grpc::RpcMethod rpcmethod_Equals_;
    const ::grpc::RpcMethod rpcmethod_Merge_;
    const ::grpc::RpcMethod rpcmethod_Clone_;
    const ::grpc::RpcMethod rpcmethod_SupportedTypes_;
    const ::grpc::RpcMethod rpcmethod_IsSupportedType_;
    const ::grpc::RpcMethod rpcmethod_SupportedStorageTypes_;
    const ::grpc::RpcMethod rpcmethod_IsSupportedStorageType_;
    const ::grpc::RpcMethod rpcmethod_SupportedCryptoMethods_;
    const ::grpc::RpcMethod rpcmethod_IsSupportedCryptoMethod_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::Channel>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status Create(::grpc::ServerContext* context, const ::crdt::CreateRequest* request, ::crdt::CreateResponse* response);
    virtual ::grpc::Status Attach(::grpc::ServerContext* context, const ::crdt::AttachRequest* request, ::crdt::AttachResponse* response);
    virtual ::grpc::Status Detach(::grpc::ServerContext* context, const ::crdt::DetachRequest* request, ::crdt::DetachResponse* response);
    virtual ::grpc::Status Commit(::grpc::ServerContext* context, const ::crdt::CommitRequest* request, ::crdt::CommitResponse* response);
    virtual ::grpc::Status Equals(::grpc::ServerContext* context, const ::crdt::EqualsRequest* request, ::crdt::EqualsResponse* response);
    virtual ::grpc::Status Merge(::grpc::ServerContext* context, const ::crdt::MergeRequest* request, ::crdt::MergeResponse* response);
    virtual ::grpc::Status Clone(::grpc::ServerContext* context, const ::crdt::CloneRequest* request, ::crdt::CloneResponse* response);
    virtual ::grpc::Status SupportedTypes(::grpc::ServerContext* context, const ::crdt::EmptyMessage* request, ::crdt::SupportedTypesResponse* response);
    virtual ::grpc::Status IsSupportedType(::grpc::ServerContext* context, const ::crdt::TypeMessage* request, ::crdt::BooleanResponse* response);
    virtual ::grpc::Status SupportedStorageTypes(::grpc::ServerContext* context, const ::crdt::EmptyMessage* request, ::crdt::SupportedStorageTypesResponse* response);
    virtual ::grpc::Status IsSupportedStorageType(::grpc::ServerContext* context, const ::crdt::TypeMessage* request, ::crdt::BooleanResponse* response);
    virtual ::grpc::Status SupportedCryptoMethods(::grpc::ServerContext* context, const ::crdt::EmptyMessage* request, ::crdt::SupportedCryptoMethodsResponse* response);
    virtual ::grpc::Status IsSupportedCryptoMethod(::grpc::ServerContext* context, const ::crdt::TypeMessage* request, ::crdt::BooleanResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService();
    ~AsyncService() {};
    void RequestCreate(::grpc::ServerContext* context, ::crdt::CreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::CreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestAttach(::grpc::ServerContext* context, ::crdt::AttachRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::AttachResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestDetach(::grpc::ServerContext* context, ::crdt::DetachRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::DetachResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestCommit(::grpc::ServerContext* context, ::crdt::CommitRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::CommitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestEquals(::grpc::ServerContext* context, ::crdt::EqualsRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::EqualsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestMerge(::grpc::ServerContext* context, ::crdt::MergeRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::MergeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestClone(::grpc::ServerContext* context, ::crdt::CloneRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::CloneResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestSupportedTypes(::grpc::ServerContext* context, ::crdt::EmptyMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SupportedTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestIsSupportedType(::grpc::ServerContext* context, ::crdt::TypeMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::BooleanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestSupportedStorageTypes(::grpc::ServerContext* context, ::crdt::EmptyMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SupportedStorageTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestIsSupportedStorageType(::grpc::ServerContext* context, ::crdt::TypeMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::BooleanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestSupportedCryptoMethods(::grpc::ServerContext* context, ::crdt::EmptyMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SupportedCryptoMethodsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestIsSupportedCryptoMethod(::grpc::ServerContext* context, ::crdt::TypeMessage* request, ::grpc::ServerAsyncResponseWriter< ::crdt::BooleanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
  };
};

class GrowOnlySet GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::crdt::ResourceObject>> List(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::crdt::ResourceObject>>(ListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>> AsyncList(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>>(AsyncListRaw(context, request, cq, tag));
    }
    virtual ::grpc::Status Insert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::crdt::SetInsertResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>> AsyncInsert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>>(AsyncInsertRaw(context, request, cq));
    }
    virtual ::grpc::Status Length(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::crdt::SetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>> AsyncLength(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>>(AsyncLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status Contains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::crdt::SetContainsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>> AsyncContains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>>(AsyncContainsRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientReaderInterface< ::crdt::ResourceObject>* ListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>* AsyncListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>* AsyncInsertRaw(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>* AsyncLengthRaw(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>* AsyncContainsRaw(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::Channel>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::crdt::ResourceObject>> List(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::crdt::ResourceObject>>(ListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::crdt::ResourceObject>> AsyncList(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::crdt::ResourceObject>>(AsyncListRaw(context, request, cq, tag));
    }
    ::grpc::Status Insert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::crdt::SetInsertResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>> AsyncInsert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>>(AsyncInsertRaw(context, request, cq));
    }
    ::grpc::Status Length(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::crdt::SetLengthResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>> AsyncLength(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>>(AsyncLengthRaw(context, request, cq));
    }
    ::grpc::Status Contains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::crdt::SetContainsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>> AsyncContains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>>(AsyncContainsRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::Channel> channel_;
    ::grpc::ClientReader< ::crdt::ResourceObject>* ListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) GRPC_OVERRIDE;
    ::grpc::ClientAsyncReader< ::crdt::ResourceObject>* AsyncListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>* AsyncInsertRaw(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>* AsyncLengthRaw(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>* AsyncContainsRaw(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_List_;
    const ::grpc::RpcMethod rpcmethod_Insert_;
    const ::grpc::RpcMethod rpcmethod_Length_;
    const ::grpc::RpcMethod rpcmethod_Contains_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::Channel>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::crdt::SetListRequest* request, ::grpc::ServerWriter< ::crdt::ResourceObject>* writer);
    virtual ::grpc::Status Insert(::grpc::ServerContext* context, const ::crdt::SetInsertRequest* request, ::crdt::SetInsertResponse* response);
    virtual ::grpc::Status Length(::grpc::ServerContext* context, const ::crdt::SetLengthRequest* request, ::crdt::SetLengthResponse* response);
    virtual ::grpc::Status Contains(::grpc::ServerContext* context, const ::crdt::SetContainsRequest* request, ::crdt::SetContainsResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService();
    ~AsyncService() {};
    void RequestList(::grpc::ServerContext* context, ::crdt::SetListRequest* request, ::grpc::ServerAsyncWriter< ::crdt::ResourceObject>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestInsert(::grpc::ServerContext* context, ::crdt::SetInsertRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetInsertResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestLength(::grpc::ServerContext* context, ::crdt::SetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestContains(::grpc::ServerContext* context, ::crdt::SetContainsRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetContainsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
  };
};

class TwoPhaseSet GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::crdt::ResourceObject>> List(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::crdt::ResourceObject>>(ListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>> AsyncList(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>>(AsyncListRaw(context, request, cq, tag));
    }
    virtual ::grpc::Status Insert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::crdt::SetInsertResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>> AsyncInsert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>>(AsyncInsertRaw(context, request, cq));
    }
    virtual ::grpc::Status Remove(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::crdt::SetRemoveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetRemoveResponse>> AsyncRemove(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetRemoveResponse>>(AsyncRemoveRaw(context, request, cq));
    }
    virtual ::grpc::Status Length(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::crdt::SetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>> AsyncLength(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>>(AsyncLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status Contains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::crdt::SetContainsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>> AsyncContains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>>(AsyncContainsRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientReaderInterface< ::crdt::ResourceObject>* ListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::crdt::ResourceObject>* AsyncListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetInsertResponse>* AsyncInsertRaw(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetRemoveResponse>* AsyncRemoveRaw(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetLengthResponse>* AsyncLengthRaw(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crdt::SetContainsResponse>* AsyncContainsRaw(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::Channel>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::crdt::ResourceObject>> List(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::crdt::ResourceObject>>(ListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::crdt::ResourceObject>> AsyncList(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::crdt::ResourceObject>>(AsyncListRaw(context, request, cq, tag));
    }
    ::grpc::Status Insert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::crdt::SetInsertResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>> AsyncInsert(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>>(AsyncInsertRaw(context, request, cq));
    }
    ::grpc::Status Remove(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::crdt::SetRemoveResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetRemoveResponse>> AsyncRemove(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetRemoveResponse>>(AsyncRemoveRaw(context, request, cq));
    }
    ::grpc::Status Length(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::crdt::SetLengthResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>> AsyncLength(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>>(AsyncLengthRaw(context, request, cq));
    }
    ::grpc::Status Contains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::crdt::SetContainsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>> AsyncContains(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>>(AsyncContainsRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::Channel> channel_;
    ::grpc::ClientReader< ::crdt::ResourceObject>* ListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request) GRPC_OVERRIDE;
    ::grpc::ClientAsyncReader< ::crdt::ResourceObject>* AsyncListRaw(::grpc::ClientContext* context, const ::crdt::SetListRequest& request, ::grpc::CompletionQueue* cq, void* tag) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetInsertResponse>* AsyncInsertRaw(::grpc::ClientContext* context, const ::crdt::SetInsertRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetRemoveResponse>* AsyncRemoveRaw(::grpc::ClientContext* context, const ::crdt::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetLengthResponse>* AsyncLengthRaw(::grpc::ClientContext* context, const ::crdt::SetLengthRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::crdt::SetContainsResponse>* AsyncContainsRaw(::grpc::ClientContext* context, const ::crdt::SetContainsRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_List_;
    const ::grpc::RpcMethod rpcmethod_Insert_;
    const ::grpc::RpcMethod rpcmethod_Remove_;
    const ::grpc::RpcMethod rpcmethod_Length_;
    const ::grpc::RpcMethod rpcmethod_Contains_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::Channel>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::crdt::SetListRequest* request, ::grpc::ServerWriter< ::crdt::ResourceObject>* writer);
    virtual ::grpc::Status Insert(::grpc::ServerContext* context, const ::crdt::SetInsertRequest* request, ::crdt::SetInsertResponse* response);
    virtual ::grpc::Status Remove(::grpc::ServerContext* context, const ::crdt::SetRemoveRequest* request, ::crdt::SetRemoveResponse* response);
    virtual ::grpc::Status Length(::grpc::ServerContext* context, const ::crdt::SetLengthRequest* request, ::crdt::SetLengthResponse* response);
    virtual ::grpc::Status Contains(::grpc::ServerContext* context, const ::crdt::SetContainsRequest* request, ::crdt::SetContainsResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService();
    ~AsyncService() {};
    void RequestList(::grpc::ServerContext* context, ::crdt::SetListRequest* request, ::grpc::ServerAsyncWriter< ::crdt::ResourceObject>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestInsert(::grpc::ServerContext* context, ::crdt::SetInsertRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetInsertResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestRemove(::grpc::ServerContext* context, ::crdt::SetRemoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetRemoveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestLength(::grpc::ServerContext* context, ::crdt::SetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
    void RequestContains(::grpc::ServerContext* context, ::crdt::SetContainsRequest* request, ::grpc::ServerAsyncResponseWriter< ::crdt::SetContainsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag);
  };
};

}  // namespace crdt


#endif  // GRPC_crdt_2eproto__INCLUDED
